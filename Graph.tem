template <typename N, typename E>
bool Graph<N,E>::compareNode::operator()(const std::weak_ptr<Node> &a, const std::weak_ptr<Node> &b){
	if(a.expired()){
		return false;
	}
	if(b.expired()){
		return true;
	}

	return a.lock()->data_ < b.lock()->data_;
}

template <typename N, typename E>
bool Graph<N,E>::addNode(const N &val) {
	// can be optimized? reset
	if(nodes_.find(val) == nodes_.end()){
		nodes_[val] = std::make_shared<Node>(val);
		return true;
	}

	return false;
}

template <typename N, typename E>
bool Graph<N,E>::isNode(const N &val) const {
	return nodes_.count(val);
}

template <typename N, typename E>
bool Graph<N,E>::isConnected(const N& src, const N& dst) const {
	std::weak_ptr<Node> d = nodes_.at(dst);
	for(const auto &entry : nodes_.at(src)->neighbours_) {
		if(entry.second.find(d) != entry.second.end()){
			return true;
		}
	}
	return false;
}

template <typename N, typename E>
void Graph<N,E>::printNodes() const {
	std::vector<std::shared_ptr<Node>> vec(nodes_.size());
	std::transform(nodes_.cbegin(), nodes_.cend(), vec.begin(), 
			[](const auto &entry) { return entry.second; });
	std::stable_sort(vec.begin(), vec.end(), 
			[](const auto &a, const auto &b) { return a->degree_ > b->degree_; });
	std::transform(vec.cbegin(), vec.cend(), 
			std::ostream_iterator<N>(std::cout, "\n"), 
			[](const auto &node) { return node->data_; });
}

template <typename N, typename E>
void Graph<N,E>::printEdges(const N& val) const {
	for(auto &weightEntry : nodes_.at(val)->neighbours_) {
		for(auto nodeEntry = weightEntry.second.begin(); nodeEntry != weightEntry.second.end();) {
			if(nodeEntry->expired()){
				auto tmp = nodeEntry++;
				weightEntry.second.erase(tmp);
			}

			std::cout << nodeEntry->lock()->data_ << ' ' << weightEntry.first << '\n';
			++nodeEntry;
		}
	}
}

template <typename N, typename E>
bool Graph<N,E>::addEdge(const N &src, const N &dst, const E &w){
	std::weak_ptr<Node> d = nodes_.at(dst);
	return nodes_.at(src)->neighbours_[w].insert(d).second;
}
