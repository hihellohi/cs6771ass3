template <typename N, typename E>
bool Graph<N,E>::compareNode::operator()(const std::weak_ptr<Node> &a, const std::weak_ptr<Node> &b) const {
	if(a.expired()){
		return false;
	}
	if(b.expired()){
		return true;
	}

	return a.lock()->data_ < b.lock()->data_;
}

template <typename N, typename E>
unsigned int Graph<N,E>::sanitize(const Node &n) const {
	unsigned int degree;
	for(auto nodeEntry = n.neighbours_.begin(); nodeEntry != n.neighbours_.end();) {
		if(nodeEntry->first.expired()) {
			auto tmp = nodeEntry++;
			n.neighbours_.erase(tmp);
		}
		else {
			++nodeEntry;
			degree += nodeEntry->second.size();
		}
	}
	return degree;
}

template <typename N, typename E>
bool Graph<N,E>::addNode(const N &val) {
	// can be optimized? reset
	if(nodes_.find(val) == nodes_.end()){
		nodes_[val] = std::make_shared<Node>(val);
		return true;
	}

	return false;
}

template <typename N, typename E>
bool Graph<N,E>::isNode(const N &val) const {
	return nodes_.count(val);
}

template <typename N, typename E>
bool Graph<N,E>::isConnected(const N& src, const N& dst) const {
	std::weak_ptr<Node> d(nodes_.at(dst));
	return nodes_.at(src)->neighbours_.count(d);
}

template <typename N, typename E>
void Graph<N,E>::printNodes() const {
	std::vector<std::pair<unsigned int, std::shared_ptr<Node>>> vec(nodes_.size());
	std::transform(nodes_.cbegin(), nodes_.cend(), vec.begin(), 
			[this](const auto &entry) { return std::make_pair(this->sanitize(*entry.second), entry.second); });
	std::sort(vec.begin(), vec.end(), 
			[](const auto &a, const auto &b) { 
				if(a.first == b.first){
					return a.second->data_ < b.second->data_;
				}
				return a.first > b.first; 
			});
	std::transform(vec.cbegin(), vec.cend(), 
			std::ostream_iterator<N>(std::cout, "\n"), 
			[](const auto &node) { return node.second->data_; });
}

template <typename N, typename E>
void Graph<N,E>::printEdges(const N& val) const {
	std::cout << "Edges attached to Node " << val << '\n';
	std::vector< std::pair<typename std::set<E>::iterator, std::shared_ptr<Node>> > vec;

	Node &n = *nodes_.at(val);
	for(auto nodeEntry = n.neighbours_.begin(); nodeEntry != n.neighbours_.end();) {
		if(nodeEntry->first.expired()) {
			auto tmp = nodeEntry++;
			n.neighbours_.erase(tmp);
		}
		else {
			for(auto weightEntry = nodeEntry->second.begin(); weightEntry != nodeEntry->second.end(); ++weightEntry) {
				vec.push_back(std::make_pair(weightEntry, nodeEntry->first.lock()));
			}
			++nodeEntry;
		}
	}

	std::sort(vec.begin(), vec.end(), 
			[](const auto &a, const auto &b) { 
				if(*a.first < *b.first) {
					return true;
				}
				else if(*b.first < *a.first) {
					return a.second->data_ < b.second->data_;
				}
				else{
					return false;
				}
			});

	if(vec.size()){
		for(auto &edge : vec){
			std::cout << edge.second->data_ << ' ' << *edge.first << '\n';
		}
	}
	else{
		std::cout << "(null)\n";
	}
}

template <typename N, typename E>
bool Graph<N,E>::addEdge(const N &src, const N &dst, const E &w){
	std::weak_ptr<Node> d = nodes_.at(dst);
	return nodes_.at(src)->neighbours_[d].insert(w).second;
}
